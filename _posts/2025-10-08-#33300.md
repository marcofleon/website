---
layout: pr
date: 2025-10-08
title: "Compact block harness"
pr: 33300
authors: [Crypt-iQ]
components: ["tests"]
host: marcofleon
status: upcoming
commit:
---

## Notes

- This PR adds a fuzz harness for testing compact block relay, along with a few test infrastructure changes to improve speed and determinism.

- The harness simulates a network environment by sending compact block messages (CMPCTBLOCK, BLOCKTXN, HEADERS, SENDCMPCT, TX) to test nodes.
 
- The goal is to find bugs and ensure assertions hold. See [#33296](https://github.com/bitcoin/bitcoin/pull/33296) for an example of a bug found by this very fuzz test. Nice!


### Compact Blocks Protocol Overview

- [BIP 152](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki) introduced the compact block relay protocol, which reduces bandwidth and latency when propagating blocks by sending compact representations that leverage the fact that most transactions in a block are already in the our peer's mempool.

- Instead of sending the full block, compact blocks send:
  - A header
  - Short transaction IDs (6 bytes instead of 32 bytes)
  - Some transactions in full (pre-filled transactions, just the coinbase in production code)

- The receiving node reconstructs the block using transactions from its mempool. If any transactions are missing, it requests them via a `GETBLOCKTXN` message.

- There are two modes: high-bandwidth (blocks sent unsolicited) and low-bandwidth (blocks sent after request via `INV`/`GETDATA`).


### Fuzz Testing

- Fuzzing is a testing technique that provides quasi-random inputs to code to discover bugs and unexpected behavior. 

- See our [fuzzing docs](https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md) to start fuzzing with libFuzzer and AFL++.

- Check out the [test coverage](https://marcofleon.github.io/coverage/cmpctblock/) (`blockencodings.cpp` and `net_processing.cpp` are probably most useful to look at). Walking through a coverage report to see which branches are hit or not hit is a good way to start evaluating a fuzz harness.

- An effective fuzz test will be deterministic, as this makes bugs easier to reproduce. If you’re able to get the AFL++ fuzzer running, you will see a stability metric. The goal is to get to 100%, perfect determinism! You can also run [this script](https://github.com/bitcoin/bitcoin/blob/master/contrib/devtools/deterministic-fuzz-coverage/src/main.rs) to check for the source of potential non-determinism in a fuzz test.


## Fun Exercise


- If you get the harness running, revert PR [#33296](https://github.com/bitcoin/bitcoin/pull/33296) and see if you can reproduce the crash on this [`Assume`](https://github.com/bitcoin/bitcoin/blob/689a32197638e92995dd8eb071425715f5fdc3a4/src/net_processing.cpp#L3333).

- Yeah I know, fuzzing is cool.


## Questions


1. Did you review the PR? Concept ACK, approach ACK, tested ACK, or NACK? What was your review approach? Were you able to get the fuzz test running?

2. Where in codebase are the main compact block helpers and processing logic? Name some of the classes and functions you looked at. (Hint: nothing like a little search for `NetMsgType::CMPCTBLOCK` to get you started)

3. The fuzz test sends `SENDCMPCT` messages with `high_bandwidth` randomly set. What is the difference between high bandwidth and low bandwidth compact block relay? How many high bandwidth peers are allowed and does the fuzz harness test this limit?

4. Compare `-testdatadir` and the new `-fuzzcopydatadir`. Why is the latter useful for performance, and why isn’t a fresh `TestingSetup` that mines blocks on each iteration acceptable here?

5. Look at `create_block` in the harness. How many transactions do the generated blocks contain, and where do they come from? What compact block scenarios might be missed with only a few transactions in a block?

6. In commit [ecba804](https://github.com/bitcoin/bitcoin/pull/33300/commits/ecba804b0d034bbb6e61510cd2161b2ae449ac8d) `FinalizeHeader` is moved to `util.h` so it can be used by any fuzz test. What does this function do and why doesn’t it stall the fuzzer?

7. Commit [e2f9214](https://github.com/bitcoin/bitcoin/pull/33300/commits/e2f921458913bcbbe74115cdb2174b0ab31784f2) sorts `m_dirty_blockindex` by block hash instead of pointer address. What non-determinism does this fix?  The author [notes](https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3308381089) this slows production code for no production benefit. Why can't `EnableFuzzDeterminism()` be used here? How do you think this non-determinism should be best handled (if not the current commit)?

8. The harness adds pre-filled transactions to a compact block beyond the coinbase (which is all we do in production code for now). Walk through the index calculations for pre-filling transactions at indices 1 and 3 in a 4-transaction block. Do you think this code could be simplified or cleaned up, and if so, what do you suggest?


<!-- TODO: After a meeting, uncomment and add meeting log between the irc tags
## Meeting Log

### Meeting 1

{% irc %}
-->
<!-- TODO: For additional meetings, add the logs to the same irc block. This ensures line numbers keep increasing, avoiding hyperlink conflicts for identical line numbers across meetings.

### Meeting 2

-->
{% endirc %}
